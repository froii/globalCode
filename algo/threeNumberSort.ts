// цікава задача, де нам потрібно розташувати елементи в масиві відповідно до визначеного порядку, 
// подібно до варіанту сортування підрахунком.

// Це рішення використовує двопрохідний підхід для сортування масиву відповідно до заданого порядку. Ось як це працює:

// Перший прохід:
// Використовує три покажчики: перший, другий і третій
// Розміщує елементи order[0] на початку та елементи order[2] у кінці
// Елементи, рівні порядку [1], залишаються в середині

// Другий прохід:
// Упорядковує інші елементи, які мають бути однаковими за порядком[1]
// Забезпечує їх розміщення між елементами order[0] і order[2].

// Часова складність: O(n), де n – довжина вхідного масиву
// Просторова складність: O(1), оскільки сортується на місці

// Зберігає відносний порядок елементів, гарантуючи, що кінцевий масив дотримується вказаного порядку
// Реалізація обробляє крайні випадки, такі як:
// Порожні масиви
// Масиви з дублікатами
// Масиви, у яких відсутні деякі елементи з масиву порядку
// Масиви, що містять усі елементи одного типу

export function threeNumberSort(array: number[], order: number[]): number[] {
    // Ініціалізуємо вказівники для першого та останнього елементів
    let first = 0;
    let second = 0;
    let third = array.length - 1;
  
    // Перший прохід: розміщуємо перше та третє число
    while (second <= third) {
      if (array[second] === order[0]) {
        // Міняємо місцями елемент на позиції second з елементом на позиції first
        [array[first], array[second]] = [array[second], array[first]];
        first++;
        second++;
      } else if (array[second] === order[2]) {
        // Міняємо місцями елемент на позиції second з елементом на позиції third
        [array[second], array[third]] = [array[third], array[second]];
        third--;
      } else {
        second++;
      }
    }
  
    // Другий прохід: розміщуємо друге число
    second = first;
    third = array.length - 1;
  
    while (second <= third) {
      if (array[second] === order[1]) {
        second++;
      } else if (array[second] === order[2]) {
        // Всі елементи після вказівника third повинні вже бути order[2]
        break;
      } else {
        // Міняємо місцями елемент на позиції second з елементом на позиції third
        [array[second], array[third]] = [array[third], array[second]];
        third--;
      }
    }
  
    return array;
  }
  
  // Приклад використання:
  // const array = [1, 0, 0, -1, -1, 0, 1, 1];
  // const order = [0, 1, -1];
  // Результат: [0, 0, 0, 1, 1, 1, -1, -1]